name: Pull Updater Artifacts

on:
  workflow_dispatch:
    inputs:
      repo:
        description: 'Repository to pull artifacts from (format: owner/repo)'
        required: true
        default: '0PandaDEV/Qopy'
      run_id:
        description: 'Action run ID to pull artifacts from'
        required: true
      version:
        description: 'Version number (optional, will be determined from files if not provided)'
        required: false

jobs:
  pull-artifacts:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download artifacts
        uses: actions/github-script@v7
        with:
          script: |
            const [owner, repo] = '${{ github.event.inputs.repo }}'.split('/');
            
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: owner,
              repo: repo,
              run_id: ${{ github.event.inputs.run_id }}
            });
            
            const updaterArtifacts = artifacts.data.artifacts.filter(
              artifact => artifact.name.toLowerCase().includes('updater')
            );
            
            let detectedVersion = null;
            
            for (const artifact of updaterArtifacts) {
              const download = await github.rest.actions.downloadArtifact({
                owner: owner,
                repo: repo,
                artifact_id: artifact.id,
                archive_format: 'zip'
              });
              
              const fs = require('fs');
              const path = require('path');
              
              // Create temporary directory for version detection
              const tempDir = 'temp_extract';
              if (!fs.existsSync(tempDir)) {
                fs.mkdirSync(tempDir);
              }
              
              // Save and extract first zip to detect version
              if (!detectedVersion) {
                const tempPath = path.join(tempDir, 'temp.zip');
                fs.writeFileSync(tempPath, Buffer.from(download.data));
                
                // Extract and look for version info
                require('child_process').execSync(`unzip -o "${tempPath}" -d ${tempDir}`);
                
                // Try to find version from various files
                const possibleFiles = ['latest.yml', 'version.txt', 'package.json'];
                for (const file of possibleFiles) {
                  const filePath = path.join(tempDir, file);
                  if (fs.existsSync(filePath)) {
                    const content = fs.readFileSync(filePath, 'utf8');
                    let versionMatch;
                    
                    if (file === 'latest.yml') {
                      versionMatch = content.match(/version:\s*(.+)/);
                    } else if (file === 'package.json') {
                      const pkg = JSON.parse(content);
                      versionMatch = pkg.version ? [null, pkg.version] : null;
                    } else {
                      versionMatch = content.trim().match(/(.+)/);
                    }
                    
                    if (versionMatch) {
                      detectedVersion = versionMatch[1].startsWith('v') ? 
                        versionMatch[1].trim() : 
                        'v' + versionMatch[1].trim();
                      break;
                    }
                  }
                }
                
                // Cleanup temp
                fs.rmSync(tempDir, { recursive: true, force: true });
              }
              
              // Use provided version or detected version
              const versionDir = '${{ github.event.inputs.version }}' || detectedVersion;
              
              if (!versionDir) {
                core.setFailed('Could not detect version and no version was provided');
                return;
              }
              
              // Check if version already exists
              if (fs.existsSync(versionDir)) {
                core.setFailed(`Version ${versionDir} already exists. Skipping to prevent overwrite.`);
                return;
              }
              
              // Create version directory and continue with artifact saving
              fs.mkdirSync(versionDir);
              
              // Save the zip file
              const artifactPath = path.join(versionDir, `${artifact.name}.zip`);
              fs.writeFileSync(artifactPath, Buffer.from(download.data));
            }

      - name: Extract artifacts
        if: success()
        run: |
          VERSION_DIR="${{ github.event.inputs.version }}"
          if [ -z "$VERSION_DIR" ]; then
            VERSION_DIR=$(ls -d v* | head -n 1)
          fi
          cd "$VERSION_DIR"
          for zip in *.zip; do
            unzip -o "$zip" -d "${zip%.zip}"
            rm "$zip"
          done

      - name: Commit and push changes
        if: success()
        run: |
          VERSION_DIR="${{ github.event.inputs.version }}"
          if [ -z "$VERSION_DIR" ]; then
            VERSION_DIR=$(ls -d v* | head -n 1)
          fi
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add "$VERSION_DIR"
          git commit -m "Add updater files for $VERSION_DIR"
          git push